name: üöÄ CI/CD - Build, Deploy & Test Firefly AI Stack

on:
  push:
    branches: [ main, develop, intgrate_with_chatgpt ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment to EC2'
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  AWS_EC2_HOST: ${{ secrets.AWS_EC2_HOST }}
  AWS_EC2_USER: ${{ secrets.AWS_EC2_USER }}
  AWS_EC2_KEY: ${{ secrets.AWS_EC2_PRIVATE_KEY }}
  FIREFLY_BASE_URL: ${{ secrets.FIREFLY_BASE_URL }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

jobs:
  # ===============================
  # BUILD & PUSH DOCKER IMAGES
  # ===============================
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      ai-image-tag: ${{ steps.meta-ai.outputs.tags }}
      webhook-image-tag: ${{ steps.meta-webhook.outputs.tags }}
      version: ${{ steps.meta.outputs.version }}
    
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for change detection

      - name: üîç Detect Changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            ai:
              - 'firefly-ai-categorizer/**'
            webhook:
              - 'webhook_service/**'
            docker:
              - 'docker-compose.yaml'
              - '.env'
              - '*.sh'

      - name: üêã Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: ÔøΩ Debug Docker Configuration
        run: |
          echo "üîç Docker Configuration Debug:"
          echo "DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}"
          echo "Docker Registry: ${{ env.DOCKER_REGISTRY }}"
          echo "AI Image will be: ${{ env.DOCKER_USERNAME }}/firefly-ai-categorizer"
          echo "Webhook Image will be: ${{ env.DOCKER_USERNAME }}/firefly-webhook-service"

      - name: ÔøΩüìù Extract Metadata
        id: meta
        run: |
          VERSION=v$(date +%Y%m%d)-${GITHUB_SHA::8}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      # Build AI Categorizer Service
      - name: ü§ñ Build AI Categorizer Metadata
        id: meta-ai
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/firefly-ai-categorizer
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.meta.outputs.version }}

      - name: üî® Build & Push AI Categorizer
        if: steps.changes.outputs.ai == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./firefly-ai-categorizer
          platforms: linux/amd64  # Removed arm64 for speed
          push: true
          tags: ${{ steps.meta-ai.outputs.tags }}
          labels: ${{ steps.meta-ai.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
            BUILD_DATE=${{ steps.meta.outputs.timestamp }}

      # Build Webhook Service
      - name: ü™ù Build Webhook Metadata
        id: meta-webhook
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/firefly-webhook-service
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.meta.outputs.version }}

      - name: üî® Build & Push Webhook Service
        if: steps.changes.outputs.webhook == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v5
        with:
          context: ./webhook_service
          platforms: linux/amd64  # Removed arm64 for speed
          push: true
          tags: ${{ steps.meta-webhook.outputs.tags }}
          labels: ${{ steps.meta-webhook.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ steps.meta.outputs.version }}
            BUILD_DATE=${{ steps.meta.outputs.timestamp }}

      - name: üîí Security Scan Images
        run: |
          echo "üîç Running security scans..."
          
          # Install Trivy
          sudo apt-get update
          sudo apt-get install -y wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install -y trivy
          
          # Scan AI service
          trivy image --exit-code 0 --severity HIGH,CRITICAL ${{ env.DOCKER_USERNAME }}/firefly-ai-categorizer:${{ steps.meta.outputs.version }}
          
          # Scan Webhook service  
          trivy image --exit-code 0 --severity HIGH,CRITICAL ${{ env.DOCKER_USERNAME }}/firefly-webhook-service:${{ steps.meta.outputs.version }}

  # ===============================
  # DEPLOY TO EC2
  # ===============================
  deploy-to-ec2:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/intgrate_with_chatgpt' || github.event.inputs.force_deploy == 'true') && needs.build-and-push.result == 'success'
    
    steps:
      - name: üêõ Debug Deploy Conditions
        run: |
          echo "üîç Debugging deployment conditions:"
          echo "Current ref: ${{ github.ref }}"
          echo "Event name: ${{ github.event_name }}"
          echo "Force deploy: ${{ github.event.inputs.force_deploy }}"
          echo "Build job result: ${{ needs.build-and-push.result }}"
          echo "Build job success: ${{ needs.build-and-push.result == 'success' }}"
          echo ""
          echo "üîë Checking secrets availability:"
          echo "AWS_EC2_HOST: ${{ secrets.AWS_EC2_HOST != '' }}"
          echo "AWS_EC2_USER: ${{ secrets.AWS_EC2_USER != '' }}"
          echo "AWS_EC2_KEY: ${{ secrets.AWS_EC2_PRIVATE_KEY != '' }}"
          echo "DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME != '' }}"
          echo "DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD != '' }}"
          echo ""
          echo "üê≥ Docker Images Info:"
          echo "AI Service Version: ${{ needs.build-and-push.outputs.version }}"
          echo "Expected AI Image: ${{ env.DOCKER_USERNAME }}/firefly-ai-categorizer:${{ needs.build-and-push.outputs.version }}"
          echo "Expected Webhook Image: ${{ env.DOCKER_USERNAME }}/firefly-webhook-service:${{ needs.build-and-push.outputs.version }}"
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.AWS_EC2_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.AWS_EC2_HOST }} >> ~/.ssh/known_hosts

      - name: üìã Prepare Deployment Files
        run: |
          # Create deployment directory
          mkdir -p deployment
          
          # Copy necessary files
          cp docker-compose.yaml deployment/
          cp configure-firefly.sh deployment/
          cp ec2-setup.sh deployment/
          cp ec2-debug.sh deployment/
          
          # Create database environment file
          cat > deployment/.db.env << EOF
          MARIADB_RANDOM_ROOT_PASSWORD=yes
          MARIADB_USER=admin
          MARIADB_PASSWORD=admin
          MARIADB_DATABASE=firefly
          EOF
          
          # Create environment file for EC2
          cat > deployment/.env << EOF
          # Firefly III Configuration for EC2
          APP_ENV=production
          APP_DEBUG=false
          SITE_OWNER=admin@firefly.ec2
          
          # OpenAI API Key
          OPENAI_API_KEY=${{ env.OPENAI_API_KEY }}
          
          # Docker Configuration
          DOCKER_USERNAME=${{ env.DOCKER_USERNAME }}
          AI_SERVICE_TAG=${{ needs.build-and-push.outputs.version }}
          WEBHOOK_SERVICE_TAG=${{ needs.build-and-push.outputs.version }}
          
          # Database Configuration
          DB_CONNECTION=mysql
          DB_HOST=db
          DB_PORT=3306
          DB_DATABASE=firefly
          DB_USERNAME=admin
          DB_PASSWORD=admin
          
          # Application URLs for EC2
          APP_URL=${{ env.FIREFLY_BASE_URL }}
          FIREFLY_URL=${{ env.FIREFLY_BASE_URL }}
          
          # API Tokens (will be generated automatically)
          FIREFLY_TOKEN=\${FIREFLY_TOKEN}
          FIREFLY_TOKEN2=\${FIREFLY_TOKEN2}
          API_TESTING_TOKEN=\${API_TESTING_TOKEN}
          API_TESTING_TOKEN2=\${API_TESTING_TOKEN2}
          
          # Encryption key (generate new one for EC2)
          APP_KEY=base64:$(openssl rand -base64 32)
          
          # Time zone
          TZ=UTC
          
          # Security settings
          TRUSTED_PROXIES=**
          
          # Log configuration
          LOG_CHANNEL=stack
          APP_LOG_LEVEL=info
          
          # Disable user registration initially (will be enabled by config script)
          DISABLE_FRAME_HEADER=false
          DISABLE_CSP_HEADER=false
          
          # Webhooks
          ALLOW_WEBHOOKS=true
          
          # Static cron token
          STATIC_CRON_TOKEN=$(openssl rand -hex 16)
          EOF

      - name: üöÄ Deploy to EC2
        run: |
          echo "üöÄ Starting deployment to EC2..."
          
          # Ensure all shell scripts have Unix line endings before transfer
          find deployment -name "*.sh" -print0 | xargs -0 sed -i 's/\r$//' 2>/dev/null || true
          
          # Make scripts executable before transfer
          find deployment -name "*.sh" -exec chmod +x {} \;
          
          # Copy files to EC2
          scp -i ~/.ssh/id_rsa -r deployment/* ${{ env.AWS_EC2_USER }}@${{ env.AWS_EC2_HOST }}:~/firefly/
          
          # Execute deployment on EC2
          ssh -i ~/.ssh/id_rsa ${{ env.AWS_EC2_USER }}@${{ env.AWS_EC2_HOST }} << 'EOF'
            set -e
            cd ~/firefly
            
            echo "ÔøΩ Debugging file presence and permissions..."
            ls -la *.sh || echo "No .sh files found"
            echo "Current directory: $(pwd)"
            echo "Directory contents: $(ls -la)"
            
            echo "ÔøΩüì¶ Updating system and installing dependencies..."
            # Fix line endings for both scripts
            for script in ec2-setup.sh ec2-debug.sh configure-firefly.sh; do
              if [ -f "$script" ]; then
                echo "Processing $script..."
                # Convert Windows line endings to Unix
                sed -i 's/\r$//' "$script" 2>/dev/null || true
                # Convert Mac line endings to Unix  
                sed -i 's/\r/\n/g' "$script" 2>/dev/null || true
                # Make executable
                chmod +x "$script"
                # Verify it's readable
                echo "File $script size: $(stat -c%s "$script" 2>/dev/null || echo "unknown")"
                echo "First line of $script: $(head -1 "$script")"
              fi
            done
            
            # Run setup with explicit bash interpreter and full path
            if [ -f ec2-setup.sh ]; then
              echo "Running ec2-setup.sh with bash interpreter..."
              /bin/bash ./ec2-setup.sh
            else
              echo "‚ö†Ô∏è ec2-setup.sh not found, running inline setup..."
              # Inline setup as fallback
              if command -v apt-get &> /dev/null; then
                sudo apt-get update -y
                sudo apt-get install -y docker.io docker-compose
              elif command -v yum &> /dev/null; then
                sudo yum update -y
                sudo yum install -y docker docker-compose
              fi
              sudo systemctl start docker || true
              sudo systemctl enable docker || true
              sudo usermod -aG docker $USER || true
            fi
            
            echo "ÔøΩ Debug: Environment variables..."
            echo "DOCKER_USERNAME: $DOCKER_USERNAME"
            echo "AI_SERVICE_TAG: $AI_SERVICE_TAG"
            echo "WEBHOOK_SERVICE_TAG: $WEBHOOK_SERVICE_TAG"
            
            echo "üîç Expected images:"
            echo "AI: $DOCKER_USERNAME/firefly-ai-categorizer:$AI_SERVICE_TAG"
            echo "Webhook: $DOCKER_USERNAME/firefly-webhook-service:$WEBHOOK_SERVICE_TAG"
            
            echo "ÔøΩüîÑ Pulling specific built images..."
            docker pull $DOCKER_USERNAME/firefly-ai-categorizer:$AI_SERVICE_TAG || echo "‚ö†Ô∏è AI image pull failed"
            docker pull $DOCKER_USERNAME/firefly-webhook-service:$WEBHOOK_SERVICE_TAG || echo "‚ö†Ô∏è Webhook image pull failed"
            
            echo "üîÑ Pulling other base images..."
            docker compose pull app db importer || true
            
            echo "‚èπÔ∏è Stopping existing services..."
            docker compose down
            
            echo "üóëÔ∏è Cleaning up old containers and images..."
            docker system prune -f
            
            echo "üöÄ Starting services..."
            docker compose up -d
            
            echo "‚è≥ Waiting for services to be ready..."
            # Smart health check instead of fixed sleep
            max_attempts=30
            attempt=0
            while [ $attempt -lt $max_attempts ]; do
              if docker compose ps | grep -q "Up (healthy)\|Up   " && \
                 curl -f http://localhost:8080/health >/dev/null 2>&1; then
                echo "‚úÖ Services are ready!"
                break
              fi
              echo "üîÑ Attempt $((attempt + 1))/$max_attempts - Services not ready yet..."
              sleep 3
              attempt=$((attempt + 1))
            done
            
            if [ $attempt -eq $max_attempts ]; then
              echo "‚ö†Ô∏è Services didn't become ready within expected time, continuing anyway..."
            fi
            
            echo "üîß Configuring Firefly III..."            
            # Run configuration with explicit bash interpreter and full path
            if [ -f configure-firefly.sh ]; then
              echo "Running configure-firefly.sh with bash interpreter..."
              /bin/bash ./configure-firefly.sh
            else
              echo "‚ö†Ô∏è configure-firefly.sh not found, skipping configuration"
            fi
            
            echo "‚úÖ Deployment completed successfully!"
          EOF

      - name: üìä Deployment Summary
        run: |
          echo "## üéâ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Version | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| AI Categorizer | \`${{ needs.build-and-push.outputs.version }}\` | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY
          echo "| Webhook Service | \`${{ needs.build-and-push.outputs.version }}\` | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY
          echo "| Firefly III Core | \`6.3.2\` | ‚úÖ Running |" >> $GITHUB_STEP_SUMMARY
          echo "| Database | \`MariaDB Noble\` | ‚úÖ Running |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üåê **Firefly III URL**: ${{ env.FIREFLY_BASE_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "üìÖ **Deployed**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  # ===============================
  # VALIDATE DEPLOYMENT
  # ===============================
  validate-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-to-ec2]
    if: always() && needs.deploy-to-ec2.result == 'success'
    
    steps:
      - name: üêõ Debug Validation Conditions
        run: |
          echo "üîç Debugging validation conditions:"
          echo "Deploy job result: ${{ needs.deploy-to-ec2.result }}"
          echo "Deploy job success: ${{ needs.deploy-to-ec2.result == 'success' }}"
          echo "Always condition: true"
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: üì¶ Install Dependencies
        run: |
          pip install --no-deps requests pytest python-dotenv

      - name: üß™ Run Deployment Tests
        env:
          FIREFLY_BASE_URL: ${{ env.FIREFLY_BASE_URL }}
        run: |
          cat > test_deployment.py << 'EOF'
          import requests
          import time
          import os
          import sys
          
          def test_service_health(url, service_name, timeout=30):
              """Test if a service is healthy"""
              print(f"üîç Testing {service_name} at {url}")
              
              for attempt in range(timeout):
                  try:
                      response = requests.get(url, timeout=5)
                      if response.status_code < 500:
                          print(f"‚úÖ {service_name}: HTTP {response.status_code}")
                          return True
                  except Exception as e:
                      print(f"‚è≥ Attempt {attempt + 1}/{timeout}: {e}")
                  
                  time.sleep(2)
              
              print(f"‚ùå {service_name}: Failed to respond")
              return False
          
          def test_api_endpoint(base_url, endpoint, service_name):
              """Test API endpoints"""
              try:
                  url = f"{base_url}{endpoint}"
                  response = requests.get(url, timeout=10)
                  
                  if response.status_code == 200:
                      print(f"‚úÖ {service_name} API: {endpoint} responded correctly")
                      return True
                  else:
                      print(f"‚ö†Ô∏è {service_name} API: {endpoint} returned {response.status_code}")
                      return False
                      
              except Exception as e:
                  print(f"‚ùå {service_name} API: {endpoint} failed - {e}")
                  return False
          
          def main():
              base_url = os.getenv('FIREFLY_BASE_URL', 'http://localhost:8080')
              
              print("üß™ Starting deployment validation tests...")
              print(f"üéØ Target: {base_url}")
              
              tests_passed = 0
              total_tests = 0
              
              # Test Firefly III Core
              total_tests += 1
              if test_service_health(base_url, "Firefly III Core"):
                  tests_passed += 1
              
              # Test AI Categorizer Service
              total_tests += 1
              ai_url = base_url.replace(':8080', ':8082') + '/health'
              if test_service_health(ai_url, "AI Categorizer"):
                  tests_passed += 1
              
              # Test Webhook Service
              total_tests += 1
              webhook_url = base_url.replace(':8080', ':8001') + '/health'
              if test_service_health(webhook_url, "Webhook Service"):
                  tests_passed += 1
              
              # Test Data Importer
              total_tests += 1
              importer_url = base_url.replace(':8080', ':81')
              if test_service_health(importer_url, "Data Importer"):
                  tests_passed += 1
              
              # Test API endpoints
              total_tests += 1
              if test_api_endpoint(base_url, '/api/v1/about', "Firefly III"):
                  tests_passed += 1
              
              # Results
              print(f"\nüìä Test Results: {tests_passed}/{total_tests} passed")
              
              if tests_passed == total_tests:
                  print("üéâ All deployment tests passed!")
                  return 0
              else:
                  print("‚ùå Some deployment tests failed!")
                  return 1
          
          if __name__ == "__main__":
              sys.exit(main())
          EOF
          
          python test_deployment.py

      - name: üîß Setup SSH for Debug
        if: failure()
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.AWS_EC2_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.AWS_EC2_HOST }} >> ~/.ssh/known_hosts

      - name: üêõ Debug Failed Deployment
        if: failure()
        run: |
          echo "üêõ Running debug script on EC2..."
          ssh -i ~/.ssh/id_rsa ${{ env.AWS_EC2_USER }}@${{ env.AWS_EC2_HOST }} << 'EOF'
            cd ~/firefly
            chmod +x ec2-debug.sh
            ./ec2-debug.sh
          EOF

  # ===============================
  # NOTIFY RESULTS
  # ===============================
  notify:
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-ec2, validate-deployment]
    if: always()
    
    steps:
      - name: üì¢ Deployment Notification
        run: |
          if [ "${{ needs.validate-deployment.result }}" == "success" ]; then
            echo "üéâ **DEPLOYMENT SUCCESS** üéâ"
            echo ""
            echo "‚úÖ Docker images built and pushed"
            echo "‚úÖ Services deployed to EC2"
            echo "‚úÖ All validation tests passed"
            echo ""
            echo "üåê Firefly III is ready at: ${{ env.FIREFLY_BASE_URL }}"
          else
            echo "‚ùå **DEPLOYMENT FAILED** ‚ùå"
            echo ""
            echo "Please check the logs and debug output above."
          fi